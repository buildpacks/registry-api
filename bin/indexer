#!/usr/bin/env node

const fs = require('fs');
const execa = require('execa');
const path = require('path');
const os = require('os');
const reindex_delay = process.env.REINDEX_DELAY || 300000;

(async () => {
    let tempPath = execa.sync('mktemp', ['-d']).stdout
    let repoPath = path.join(tempPath, 'tmp')
    let indexPath = path.join(tempPath, "index.json")
    let lastSha = "";
    let currentSha = "";
    while (true) {
        console.log('at=main level=info msg="trying to update registry-index repo"');
        currentSha = await createUpdateRepo(repoPath);
        if (!currentSha) {
            console.log('at=main level=warn msg="failed to update registry-index repo"');
        } else if (currentSha === lastSha) {
            console.log('at=main level=info msg="registry-index repo unchanged"');
        } else {
            console.log('at=main level=info msg="building index config data cache"');
            fs.writeFileSync(indexPath, JSON.stringify(getNormalisedRegistry(repoPath)))
            console.log('at=main level=info msg="serialized index to file"');
            await buildIndex(indexPath)
            console.log('at=main level=debug msg="done building index config data cache"');
            lastSha = currentSha;
        }
        await sleep(reindex_delay); // wait some time before trying again
    }
})();

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function buildIndex(indexPath) {
    try {
        let subProc = execa('./bin/index-buildpacks', [indexPath])
        subProc.stdout.pipe(process.stdout);
        subProc.stderr.pipe(process.stderr);
        await subProc
    } catch (err) {
        console.error(err);
    }
}

function getNormalisedRegistry(registryPath) {
    const files = fs.readdirSync(registryPath);

    // Pre-filter all hidden files/dirs and files at the root level
    let dirsBuffer = files.filter(file => {
        return file[0] !== '.' && fs.statSync(path.join(registryPath, file)).isDirectory();
    }).map(filename => path.join(registryPath, filename));

    let registry = [];
    while(dirsBuffer.length > 0) {
        let tempBuffer = [];

        dirsBuffer.forEach(file => {
            if (fs.statSync(file).isDirectory()) {
                const childrenFiles = fs.readdirSync(file);
                childrenFiles.forEach(childFile => {
                    tempBuffer.push(path.join(file, childFile));
                });
            } else {
                const registryFile = fs.readFileSync(file, 'UTF-8');
                registry = registry.concat(registryFile.split(os.EOL).map(line => {
                    try {
                        return Object.assign(JSON.parse(line), {
                            description: '',
                            license: ''
                        });
                    } catch (error) {
                        // Do nothing
                    }
                }).filter(element => !!element));
            }

            dirsBuffer = tempBuffer;
        });
    }

    return registry;
}

async function createUpdateRepo(repoPath) {
    try {
        if (fs.existsSync(repoPath)) {
            try {
                await execa('git', ['-C', `${repoPath}`, 'pull']);
            } catch (error) {
                console.error(error);
                return;
            }
        } else {
            fs.mkdirSync(repoPath);
            await execa('git', ['clone', 'https://github.com/buildpacks/registry-index.git', `${repoPath}`]);
        }
    } catch (err) {
        console.error(err);
        return;
    }

    try {
      const cmd = await execa('git', ['rev-parse', 'HEAD']);
      return cmd.stdout.trim();
    } catch(err) {
      console.error(err);
    }
}
